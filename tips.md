## 第1章 程序设计入门
1. 获得pi(acos为反余弦函数)：
`const double pi=acos(-1,0)`
2. 不要让程序“按任意键退出”，如调用：
```
system("pause");
getchar();
```
3. 你的程序不能直接读取键盘和控制屏幕，所以不要使用以下函数，不要使用头文件conio.h：
`getch()/getche()/gotoxy()/clrscr();`
4. 每行的行首不应有空格，但行末通常可以有多余空格。输出的每两个数或字符串之间应以单个空格隔开。
5. 尽量用const关键字声明常数。
6. %模除10取个位；/整除10去掉个位；%模除100取后两位；/整除100去掉后两位。以此类推。
7. 使用%03d可以输出025.
8. 三角函数使用弧度而非角度。
## 第2章 循环结构程序设计
TODO  
## 第3章 数组和字符串
1. 将输入存到数组中(这里a的空间可以开大一点，数组实际的长度可以由n来确定)：
```
while(scanf("%d",&a)==1)
    a[n++]=x;
```
赋值与自增同时完成:
`a[n++]=x;`
2. 从数组a复制k/全部元素到数组b，不能直接复制，C语言的数组不是“一等公民”:
```
memcpy(b,a,sizeof(int)*k);
memcpy(b,a,sizeof(a));   
```
3. 把数组a清零(在string.h中定义):  
`memset(a,0,sizeof(a));`
4. 合并完成赋值:  
`tot=a[x=0][y=n-1]=1;`
5. scanf("%s",s); 不要加&。使用scanf输入字符串，碰到空格或是tab就会停下来。  
6. 输出到字符串:  
`sprintf(buf,"%d%d%d%d%d",abc,de,x,y,z);`
7. 在一个字符串中查找单个字符:  
`strchr(s,buf[i]) `
8. 字符串的赋值/比较/连接:  
`strcpy(a,b);/strcmp(a,b)/strcat(a,b);`
9. 读取一个打开的文件fin，读取一个字符，然后返回一个int值。如果文件结束，fgetc将返回一个特殊标记EOF，它不是一个char。所以读取一个字符应在检查其不是EOF后再将其转化为char类型，getchar同理。
```    
fgets(fin); 
c=getchar()!=EOF  
```
10. getchar等价于fgetc(stdin)，从标准输入读取一个字符  
11. 读取完整的一行，其中buf的声明为char buf[maxn]。这个函数读取不超过maxn-1个字符，然后在末尾添上结束符\0:  
`fgets(buf,maxn,fin)  `
12. 判断字符的属性，这些函数在ctype.h中定义:  
```
isalpha(a)
isdigit(a)
isprint(a)
```
13. 转换大小写:  
`toupper/tolower`
14. \o,\oo,\ooo表示八进制(o为一个八进制数字)；\xh表示十六进制(h为十六进制数字串)  
15. 二进制中，8位最大整数就是8个1，即$2^8-1$，用C语言表示为(1<<8)-1 
16. 用于循环遍历一个字符串。其中p是遍历的起点，i是步长，n是字符串的长度。%n可以在遍历到结尾时自动跳到字符串开头:  
`s[(p+i)%n];`
17. 验证具有周期性的字符串中，每个周期子串是否完全相同(习题3-4):  
`s[k] != s[k+j*i]`
k用于遍历周期子串中的每个字符，j代表周期的个数，i代表周期(即周期子串中字符的个数)
18. 在线评测系统错误类型  
· 答案错(Wrong Answer,WA)
· 输出格式错(Presentation Error,PE)
· 超时(Time Limit Exceeded,TLE)
· 运行错(Runtime Error,RE)
19. 像习题3-5、3-6这样的字谜题，可能先需要输入网格大小，再输入网格内容，最后以0表示所有输入用例结束(如习题3-6)。此时处理输入时需要把(网格大小-网格内容)当做一组，最后的0视为一组。使用循环：
`while(scanf("%d",&y)!=0){}`
然后在循环体中接收一组的所有输入，再把这一组的问题处理掉。注意while中的scanf收到的可能是0，也可能是某组的有意义的信息，要直接把它赋给有意义的变量。在循环体中处理的时候可能需要跳过这第一个输入(如习题3-5)。这种题目对输入数据的处理要认真体会！ 
## 第4章 函数和递归
1. 函数的参数和返回值最好是“一等公民”，比如int、char、double等；如果函数不需要返回值，则返回类型应写成void
2. 在算法竞赛中，请总是让main函数返回0
3. 往往用以下方式定义一个新类型名：
`typedef struct{域定义;}类型名;`
4. 对复杂的表达式进行化简可以减少计算量和避免中间结果溢出
5. 把谓词(用来判断某事物是否具有某种性质的函数)命名为“is_xxx”的形式，返回int值，非0表示真，0表示假
6. C语言用调用栈(Call Stack)来描述函数之间的调用关系。调用栈有栈帧(Stack Frame)组成，每个栈帧对应着一个为运行完的函数。在gdb中可以用backtrace(简称bt)命令打印所有栈帧信息。若要用p命令打印一个非当前栈帧的局部变量，可以用frame命令选择另一个栈帧。
7. 使用gdb调试的步骤  
· 第一步：编译程序
`gcc swap.c -std=c99 -g`
生成可执行程序a.exe(在Linux下是a.out)。-g生成调试信息。-std=c99按照C99标准编译代码
· 第2步：运行gdb
`gdb a.exe`
· 第3步：查看源码(这里(gdb)是gdb的提示符)
`(gdb) l`
· 第4步：加断点并运行
`(gdb) b 4`
`(gdb) r`
· 第5步：查看调用栈
`(gdb) bt`
`(gdb) up`选择上一个栈帧
8. *a是指“a指向的变量”，而不仅是“a指向的变量的所有值”，它可以放在赋值号的左边或右边。`*a=*a+1`是让a指向的变量自增1，甚至可以把它写成`(*a)++`。
9. 以数组为参数调用函数时，实际上只有数组首地址传递给了函数，需要另加一个参数表示元素个数
10. 若p是指针，k是正整数，则p+k就是指针p后面第k个元素，p-k就是p前面第k个元素。而如果p1和p2是类型相同的指针，则p2-p1是从p1到p2的元素个数(不含p2)
11. 用递归法计算阶乘：
```
int f(int n){
    return n==0 ? 1: f(n-1)*n;
}
```
12. 在可执行文件中：
· 正文段(Text Segment)用于储存指令
· 数据段(Data Segment)用于储存已初始化的全局变量
· BBS段(BBS Segment)用于储存未赋值的全局变量所需要的空间
运行时创建(不在可执行文件中)：
· 堆栈段(Stack Segment)用于储存调用栈，因此保存着函数的调用关系和局部变量
段被越界访问就会出现段错误(Segment Fault)，在堆栈段中被称为栈溢出(Stack Overflow)
13. Linux中，栈大小并没有储存在可执行程序中，只能用以下命令修改：
`显示当前栈大小：ulimit -a`
`把栈大小指定为32MB：ulimit -s 32768`
在Windows中，栈大小储存在可执行程序中，可用以下命令指定：
`gcc -Wl,--stack=<byte count>`
14. 判断变量a是否为0：
`if(!a)`
15. 常用函数及头文件  
|函数|作用|头文件|
|:-:|:-:|:-:|
|printf/scanf及其兄弟|格式化输入输出|stdio.h|
## 附录A 开发环境与方法
### A.1 命令行
|分类|Linux命令|Windows命令|
|:-:|:-:|:-:|
|文件列表|ls|dir|
|改变/创建/删除目录|cd/mkdir/redir|cd/md/rd|
|显示文件内容|cat/more|type/more|
|比较文件内容|diff|fc|
|修改文件属性|chmod|attrib|
|复制文件|cp|copy/xcopy|
|删除文件|rm|del|
|文件改名|mv|ren|
|回显|echo|echo|
|关闭命令行|exit|exit|
|在文件中查找字符|grep|find|
|查看/修改环境变量|set|set|
|帮助|man<命令>|help<命令>|
### A.3 编译器和调试器
#### A.3.2 常见编译选项
1. 编译.c文件(程序没有输出，代表一切均好)，得到a.exe(Win下)或a.out(Linux下)：
`gcc test.c`
对编译出的可执行文件命名，得到test.exe(Win下)或test(Linux下)：
`gcc test.c -o test`
2. 编译器选项：
输出警告：
`-Wall`
检查代码是否符合ANSI标准：
`-ansi-pedantic`
3. 条件编译
定义符号(DEBUG和LOCAL)：
```
-D DEBUG
-D LOCAL
```
这样位于
```
#ifdef DEBUG/LOCAL  
···  
#endif
```
中间的语句会被编译
4. 使用以下参数对代码进行速度优化(速度递增)：
`-O1、-O2、-O3`
#### A.3.3 gdb简介
|简写|全称|备注|
|:-:|:-:|:-:|
|l|list|显示指定行号或者指定函数附近的源代码|
|b|break|在指定行号或者指定函数开头处设置断点。如b main|
|r|run|运行程序，知道程序结束或者遇到断点而停下|
|c|continue|在程序中断后继续执行程序，知道程序结束或者遇到断点而停下。注意在程序开始执行前只能用r，不能用c|
|n|next|执行一条语句。如果有函数调用，则把它作为一个整体|
|s|step|执行一条语句。如果有函数调用，则进入函数内部|
|u|until|执行到指定行号或者指定函数开头|
|p|print|显示变量或表达式的值|
|disp|display|把一个表达式设置为display，当程序每次停下来时都会显示其值|
|cl|clear|取消断点，和b的格式相同。如果该位置有多个断点，将同时取消|
|i|info|显示各种信息。如i b显示所有断点，i disp显示display，而i lo显示所有局部变量(lo为local的简写)|
1. 使用gdb调试(之前要编译时加上-g，生成调试用的符号表)：
`gdb test.exe`
2. 显示命令 
显示第15行：
`l 15`
显示main函数开头的附近10行：
`l main`
不加参数执行l，将显示下10行，list -将显示上10行
3. 删除/临时禁止/临时回复一些display：
```
delete display (简写为d disp)
disable display (简写为dis disp)
enable display (简写为en disp)
```
类似的，也可根据断点编号删除、禁止和恢复断点